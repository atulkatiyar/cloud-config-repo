package com.lseg.ipps.solutions.shared.config;

import com.github.benmanes.caffeine.cache.Cache;
import com.lseg.ipps.solutions.shared.model.CacheEntry;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = {CacheConfig.class})
@TestPropertySource(properties = {
    "app.cache.config.maxSize=100"
})
class CacheConfigTest {

    @Autowired
    private Cache<String, CacheEntry> cacheStorage;

    @Test
    void testCacheInitialization() {
        assertNotNull(cacheStorage, "Cache should be initialized");
    }

    @Test
    void testCacheMaxSize() {
        // Fill cache beyond max size
        for (int i = 0; i < 150; i++) {
            cacheStorage.put("key" + i, new CacheEntry("value" + i));
        }

        // Verify size doesn't exceed maximum
        long cacheSize = cacheStorage.estimatedSize();
        assertTrue(cacheSize <= 100, "Cache size should not exceed configured maximum");
    }

    @Test
    void testCacheOperations() {
        // Test put and get
        CacheEntry entry = new CacheEntry("testValue");
        cacheStorage.put("testKey", entry);
        
        CacheEntry retrieved = cacheStorage.getIfPresent("testKey");
        assertNotNull(retrieved, "Retrieved entry should not be null");
        assertEquals("testValue", retrieved.getValue(), "Retrieved value should match stored value");

        // Test removal
        cacheStorage.invalidate("testKey");
        assertNull(cacheStorage.getIfPresent("testKey"), "Entry should be removed after invalidation");
    }

    @Test
    void testCacheEviction() {
        // Fill cache to max
        for (int i = 0; i < 100; i++) {
            cacheStorage.put("key" + i, new CacheEntry("value" + i));
        }

        // Add one more entry to trigger eviction
        cacheStorage.put("newKey", new CacheEntry("newValue"));

        // Verify some earlier entries have been evicted
        boolean hasEviction = false;
        for (int i = 0; i < 100; i++) {
            if (cacheStorage.getIfPresent("key" + i) == null) {
                hasEviction = true;
                break;
            }
        }
        assertTrue(hasEviction, "Cache should have evicted some entries");
    }

    // Test configuration for different max size
    @TestConfiguration
    static class AlternateCacheConfigTest {
        
        @Bean
        @Primary
        public Cache<String, CacheEntry> alternateCacheStorage() {
            return Caffeine.newBuilder()
                    .maximumSize(50)
                    .build();
        }
    }

    @Test
    void testDifferentMaxSize() {
        Cache<String, CacheEntry> alternateCache = new AlternateCacheConfigTest().alternateCacheStorage();
        
        // Fill beyond alternate max size
        for (int i = 0; i < 75; i++) {
            alternateCache.put("key" + i, new CacheEntry("value" + i));
        }

        assertTrue(alternateCache.estimatedSize() <= 50, 
            "Alternate cache size should not exceed configured maximum");
    }
}
