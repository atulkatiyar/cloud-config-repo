package com.lseg.ipps.solutions.shared.solutions.cache;

import java.util.concurrent.*;
import java.util.function.Function;

public class Log4JCache {

    private final ConcurrentMap<String, Object> cache = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, Long> timestamps = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    private final TimeUnit timeUnit;

    private final long expirationDuration;

    private static Log4JCache instance;

    public static Log4JCache getInstance(TimeUnit timeUnit, long expirationDuration) {
        if (instance != null) {
            return instance;
        }
        synchronized (Log4JCache.class) {
            if (instance == null) {
                instance = new Log4JCache(timeUnit, expirationDuration);
            }
        }
        return instance;
    }

    public static boolean checkIfLog4JCacheIsNull() {
        return instance == null;
    }

    private Log4JCache(TimeUnit timeUnit, long expirationDuration) {
        this.timeUnit = timeUnit;
        this.expirationDuration = expirationDuration;
        scheduler.scheduleAtFixedRate(
                this::removeExpiredEntries, 0, expirationDuration, timeUnit);
    }

    public Object get(String key) {
        return cache.get(key);
    }

    public Object put(String key, Object value) {
        timestamps.put(key, System.currentTimeMillis());
        return cache.put(key, value);
    }

    public Object computeIfAbsent(
            String key, Function<? super String, ? extends Object> mappingFunction) {
        timestamps.putIfAbsent(key, System.currentTimeMillis());
        return cache.computeIfAbsent(
                key,
                k -> {
                    Object value = mappingFunction.apply(k);
                    timestamps.put(k, System.currentTimeMillis());
                    return value;
                });
    }

    public boolean remove(String key, Object value) {
        timestamps.remove(key);
        return cache.remove(key, value);
    }

    public void clearAll(String key) {
        timestamps.remove(key);
        cache.remove(key);
    }

    public void removeExpiredEntries() {
        long expirationThreshold =  (System.currentTimeMillis() - timeUnit.toMillis(expirationDuration));
        for (String key : cache.keySet()) {
            Long timeStamp = timestamps.get(key);
            if (timeStamp != null && timestamps.get(key) <= expirationThreshold) {
                timestamps.remove(key);
                cache.remove(key);
            }
        }
    }

    public void shutdown() {
        scheduler.shutdown();
    }
}
